var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { sign, decode } from "jsonwebtoken";
import { v4 as uuidv4 } from "uuid";
import { TokenType, } from "../types";
import { logger } from "./LoggerService";
export default class AuthService {
    constructor(accessKey, secret) {
        this.accessKey = accessKey;
        this.secret = secret;
    }
    /**
     * Management token allows to make API calls to 100ms backend.
     * @returns Management token of type `ManagementToken`
     */
    getManagementToken(tokenConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((tokenConfig === null || tokenConfig === void 0 ? void 0 : tokenConfig.forceNew) ||
                !this.managementToken ||
                this.isTokenExpired(this.managementToken.token)) {
                logger.debug("Generating management token", tokenConfig);
                this.managementToken = yield this.generateToken(TokenType.Management, tokenConfig);
            }
            return this.managementToken;
        });
    }
    /**
     * Auth Token allows for joining Room on client side.
     * @returns Auth token of type `AuthToken`
     */
    getAuthToken(tokenConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const details = {
                room_id: tokenConfig.roomId,
                role: tokenConfig.role,
            };
            if (tokenConfig.userId) {
                details.user_id = tokenConfig.userId;
            }
            return this.generateToken(TokenType.Auth, tokenConfig, details);
        });
    }
    generateToken(type, config = {}, extras = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // buffer to handle slight mismatch between time of token creating server and HMS backend
            const bufferSeconds = 10;
            const currTimeSeconds = Math.floor(Date.now() / 1000);
            const iat = config.issuedAt || currTimeSeconds - bufferSeconds;
            const nbf = config.notValidBefore || iat;
            const exp = nbf + (config.validForSeconds || 24 * 3600);
            const payload = Object.assign({ access_key: this.accessKey, type, version: 2, iat,
                nbf,
                exp }, extras);
            const token = yield this.signAndGetJwt(payload);
            return { token };
        });
    }
    isTokenExpired(token) {
        try {
            const { exp } = decode(token);
            const buffer = 30; // generate new if it's going to expire soon
            const currTimeSeconds = Math.floor(Date.now() / 1000);
            return !exp || exp + buffer < currTimeSeconds;
        }
        catch (err) {
            logger.error("Error in decoding token", err);
        }
    }
    signAndGetJwt(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const jwtid = uuidv4();
            const options = {
                algorithm: "HS256",
                jwtid,
            };
            return new Promise((resolve, reject) => {
                sign(payload, this.secret, options, (err, token) => {
                    if (err || !token) {
                        reject(err);
                    }
                    else {
                        resolve(token);
                    }
                });
            });
        });
    }
}
//# sourceMappingURL=AuthService.js.map