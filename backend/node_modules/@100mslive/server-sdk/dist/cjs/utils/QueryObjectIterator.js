"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryObjectIterator = void 0;
/**
 * An Iterator class that accepts a `queryFunction` and iterates through it
 * asynchronously and yields an object of type `T`.
 * This is to be used for queries like {@link https://www.100ms.live/docs/server-side/v2/api-reference/Rooms/list-rooms List Rooms}
 * that return only a certain number(limit) of objects in one request, and subsequent requests have
 * to be made to completely iterate through it.
 * @internal
 * @example
 * ## Using the Iterable
 * ```ts
 * const randomObjects = createRandomObjectIterable();
 * for await (const randomObj of randomObjects){
 *  console.log(randomObj);
 *  if(randomObjects.isNextCached){
 *    console.log("next randomObj is ready to be consumed")
 *  }
 * }
 * ```
 */
class QueryObjectIterator {
    constructor(queryFunction, queryParams) {
        this.queryFunction = queryFunction;
        this.queryParams = queryParams !== null && queryParams !== void 0 ? queryParams : {};
        this.isNextCached = false;
    }
    /**
     * The implementation of `Symbol.asyncIterator` that iteratively runs the
     * `queryFunction` and yields an object of type `T`.
     */
    [Symbol.asyncIterator]() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        return __asyncGenerator(this, arguments, function* _m() {
            // if first iteration (results is undefined) or latest query returned data
            while (!this.results ||
                ((_a = this.results) === null || _a === void 0 ? void 0 : _a.data) ||
                ((_b = this.results) === null || _b === void 0 ? void 0 : _b.events)) {
                // set "last" of latest query as "start" for current query
                if (((_c = this.results) === null || _c === void 0 ? void 0 : _c.last) || ((_d = this.results) === null || _d === void 0 ? void 0 : _d.next)) {
                    this.queryParams.start =
                        (_f = (_e = this.results) === null || _e === void 0 ? void 0 : _e.last) !== null && _f !== void 0 ? _f : (_g = this.results) === null || _g === void 0 ? void 0 : _g.next;
                }
                // call query function and set `isNextCached` to true
                this.results = yield __await(this.queryFunction(this.queryParams));
                this.isNextCached = true;
                let data = (_j = (_h = this.results) === null || _h === void 0 ? void 0 : _h.data) !== null && _j !== void 0 ? _j : (_k = this.results) === null || _k === void 0 ? void 0 : _k.events;
                if (data) {
                    // iterate through returned data if present and yield it
                    for (let i = 0; i < data.length; i++) {
                        // before yielding the last element in data, set `isNextCached` to false
                        if (i == data.length - 1) {
                            this.isNextCached = false;
                        }
                        yield yield __await(data[i]);
                    }
                    // if returned data count is less than specified `limit` or default 10
                    // or `null` or an empty string, then break the loop
                    // since the final page has been reached
                    if (data.length < ((_l = this.queryParams.limit) !== null && _l !== void 0 ? _l : 10) ||
                        this.results.last == null ||
                        this.results.last == "")
                        break;
                }
            }
        });
    }
}
exports.QueryObjectIterator = QueryObjectIterator;
//# sourceMappingURL=QueryObjectIterator.js.map